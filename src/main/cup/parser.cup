package ParserLexer;

import java_cup.runtime.*;

action code {:
    public void hola() {
        System.out.println("hola");
    }
    public void adios() {
        System.out.println("adios");
    }
:}

parser code {:
    // Connect this parser to a scanner!
    lexer lex;

    @SuppressWarnings("deprecation")
    public parser(lexer lex){
        this.lex=lex;
        this.symbolFactory = new DefaultSymbolFactory();
    }
:}

/* define how to connect to the scanner! */
init with {: :};
scan with {: return lex.next_token(); :};

/* Terminales (tokens retornados por el scanner). */
// Lexema Separador ( , )
terminal PINO;
// Operadores Aritméticos Binarios ( +, -, *, /, %, ** ):
terminal DASHER, DANCER, PRANCER, VIXEN, COMET, RUDOLPH;
// Operadores Aritméticos Unarios ( ++, -- ):
terminal GRINCH, QUIEN;
// Operadores Relacionales ( ==, !=, >, <, =<, =< ):
terminal ALABASTER, BUSHY, PEPPER, SUGARPLUM, WUNORSE, JINGLE;
// Operadores Logicos ( ^, #, ! ):
terminal MELCHOR, GASPAR, BALTAZAR;
// Tipos de Datos ( char, int, float, boolean, string ):
terminal SANTACLAUS, FATHERCHRISTMAS, KRISKRINGLE, SANNICOLAS, DEDMOROZ;
// Literales
terminal char L_SANTACLAUS; // Nuestro scanner provee l_SANTACLAUS como char
terminal int L_FATHERCHRISTMAS; // Nuestro scanner provee l_SANTACLAUS como int
terminal float L_KRISKRINGLE; // Nuestro scanner provee l_SANTACLAUS como float
terminal boolean L_SANNICOLAS; // Nuestro scanner provee l_SANTACLAUS como boolean
terminal String L_DEDMOROZ; // Nuestro scanner provee l_SANTACLAUS como String
// Parentesis ( (, ), [, ], {, } ):
terminal ABRECUENTO, CIERRACUENTO, ABREEMPAQUE, CIERRAEMPAQUE, ABREREGALO, CIERRAREGALO;
// Lexemas de Estructuras de Control ( if, elif, else, for, do, until, return, break ):
terminal ELFO, HADA, DUENDE, ENVUELVE, HACE, REVISA, ENVIA, CORTA;
// Lexemas de Lectura/Escritura ( print, read ):
terminal NARRA, ESCUCHA;
// Lexema de Fin de Expresión ( | ):
terminal FINREGALO;
// Lexema de Asignación ( <= ):
terminal ENTREGA;
// Identificador ( variable, función ):
terminal PERSONA;
// EXTRA:
terminal LOCAL;
terminal FUNCTION;
terminal MAIN;

// No terminales
nonterminal navidad; //Inicial
nonterminal block; // Bloque de código
nonterminal type, arr_type; //Tipos y tipos de arreglo
nonterminal func_decl, func_decl_list, var_decl, arr_decl; // Declaraciones
nonterminal param_list, param; // Parámetros
nonterminal var_decl_init, arr_decl_init; // Variables y arreglos inicializados
nonterminal stmt, init_stmt, expr_stmt, assg_stmt, ctrl_struct_stmt, input_output_stmt, return_stmt, break_stmt; // Declaraciones
nonterminal stmt_list; //Lista de declaraciones
nonterminal conditional_stmt, iter_stmt; // Estructuras de control
nonterminal elif_else;
nonterminal do_until_loop, for_loop;
nonterminal read_stmt, write_stmt;
nonterminal expr, expr_list; // Expresiones
nonterminal and_expr, not_expr, rel_expr, rel_op;
nonterminal add_sub_expr, add_sub_ops;
nonterminal mul_div_expr, mul_div_ops;
nonterminal exp_expr;
nonterminal un_arith_expr, un_arith_ops;
nonterminal factor;
nonterminal mutable, immutable; // Mutable o inmutable
nonterminal call; // Llamada a función
nonterminal args, arg_list; // Argumentos
nonterminal literal; // Literales
nonterminal var_id, arr_id, identifier, var_init, arr_init;
start with navidad;

/**********************************************************************************************************************/

navidad ::= func_decl_list {: System.out.println("ENTRY"); :};


func_decl_list ::= func_decl
                 | func_decl func_decl_list {: //System.out.println("FUNCTION LIST") ;:};

func_decl ::= FUNCTION identifier ABRECUENTO param_list CIERRACUENTO block {: System.out.println("FUNCTION"); :};

identifier ::= var_id | arr_id;

type ::= FATHERCHRISTMAS{: //System.out.println("INT"); :}
       | KRISKRINGLE {: //System.out.println("FLOAT"); :}
       | SANTACLAUS {: //System.out.println("CHAR"); :}
       | DEDMOROZ {: //System.out.println("STRING"); :}
       | SANNICOLAS {: //System.out.println("BOOL"); :};

var_id ::= type PERSONA {: System.out.println("VAR_ID"); :};

arr_id ::= type PERSONA ABREEMPAQUE CIERRAEMPAQUE {:System.out.println("ARR_ID");:}
         | type PERSONA ABREEMPAQUE expr CIERRAEMPAQUE {:System.out.println("ARR_ID");:};

param_list ::= identifier
             | identifier PINO param_list
             | ;

block ::= ABREREGALO stmt_list CIERRAREGALO;

init_stmt ::= var_decl_init FINREGALO
            | arr_decl_init FINREGALO;

var_decl_init ::= var_init | var_decl;

var_init ::= var_decl ENTREGA expr {: System.out.println("VAR_INIT"); :};

var_decl ::= LOCAL var_id {: System.out.println("VAR_DECL"); :};

arr_decl_init ::= arr_init | arr_decl;

arr_init ::= arr_decl ENTREGA ABREEMPAQUE expr_list CIERRAEMPAQUE {: System.out.println("ARR_INIT"); :};

arr_decl ::= LOCAL arr_id {: System.out.println("ARR_DECL"); :};

expr_list ::= expr
            | expr PINO expr_list;

/**********************************************************************************************************************/

stmt ::= init_stmt
       | expr_stmt
       | assg_stmt
       | ctrl_struct_stmt
       | input_output_stmt
       | return_stmt
       | break_stmt;

stmt_list ::= stmt stmt_list
            | ;

expr_stmt ::= expr FINREGALO
            | FINREGALO;


assg_stmt ::= mutable ENTREGA expr FINREGALO;


ctrl_struct_stmt ::= conditional_stmt
                   | iter_stmt;

conditional_stmt ::= ELFO ABRECUENTO expr CIERRACUENTO block elif_else;

elif_else ::= HADA ABRECUENTO expr CIERRACUENTO block elif_else
            | DUENDE block
            | ;

iter_stmt ::= do_until_loop
            | for_loop;

do_until_loop ::= HACE block REVISA ABRECUENTO expr CIERRACUENTO FINREGALO;

for_loop ::= ENVUELVE ABRECUENTO var_init FINREGALO expr FINREGALO expr CIERRACUENTO block
           | ENVUELVE ABRECUENTO assg_stmt expr FINREGALO expr CIERRACUENTO block;

input_output_stmt ::= read_stmt FINREGALO
                    | write_stmt FINREGALO;

read_stmt ::= NARRA ABRECUENTO PERSONA CIERRACUENTO;

write_stmt ::= ESCUCHA ABRECUENTO expr CIERRACUENTO;

return_stmt ::= ENVIA expr_stmt;

break_stmt ::= CORTA FINREGALO;

expr ::= and_expr GASPAR expr
       | and_expr;


and_expr ::= not_expr MELCHOR and_expr
           | not_expr;


not_expr ::= BALTAZAR rel_expr
           | rel_expr;

rel_expr ::= add_sub_expr rel_op rel_expr
           | add_sub_expr;

rel_op ::= ALABASTER
         | BUSHY
         | PEPPER
         | SUGARPLUM
         | WUNORSE
         | JINGLE;


add_sub_expr ::= mul_div_expr add_sub_ops add_sub_expr
               | mul_div_expr;

add_sub_ops ::= DASHER
              | DANCER;


mul_div_expr ::= exp_expr mul_div_ops mul_div_expr
               | exp_expr;

mul_div_ops ::= PRANCER
              | VIXEN
              | COMET;

exp_expr ::= un_arith_expr RUDOLPH exp_expr
           | un_arith_expr;


un_arith_expr ::= un_arith_ops un_arith_expr
                | factor;

un_arith_ops ::= GRINCH
               | QUIEN
               | DANCER;

factor ::= immutable
         | mutable;

mutable ::= PERSONA
          | PERSONA ABREEMPAQUE expr CIERRAEMPAQUE;

immutable ::= ABRECUENTO expr CIERRACUENTO
            | call
            | literal;

call ::= PERSONA ABRECUENTO args CIERRACUENTO {:System.out.println("CALL");:};

args ::= arg_list
       | ;

arg_list ::= expr PINO arg_list
           | expr;

literal ::= L_SANTACLAUS
          | L_FATHERCHRISTMAS
          | L_KRISKRINGLE
          | L_SANNICOLAS
          | L_DEDMOROZ;
